name: "Callable HTTPX Scan"

on:
  workflow_call:
    inputs:
      url_artifact_name:
        description: 'The name of the artifact containing non-static-urls.txt'
        required: true
        type: string
      run_id:
        description: 'A unique ID for this run to create unique artifact names'
        required: true
        type: string
    outputs:
      result_artifact_name:
        description: 'The name of the artifact containing the final live-urls.txt'
        value: ${{ jobs.consolidate-results.outputs.artifact_name }}

jobs:
  scan-in-parallel:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        # Running on 20 parallel jobs
        chunk: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
    steps:
      - name: Install httpx
        run: |
          go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Download URL list artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ github.event.inputs.url_artifact_name }}
          path: .

      - name: Generate URL chunk file
        id: generate_chunk
        run: |
          INPUT_FILE="non-static-urls.txt"
          CHUNK_FILE="httpx-chunk-${{ matrix.chunk }}.txt"

          if [ ! -s "$INPUT_FILE" ]; then
            echo "URL file is empty, creating empty chunk file."
            touch "$CHUNK_FILE"
            echo "is_empty=true" >> $GITHUB_OUTPUT
          else
            TOTAL_LINES=$(wc -l < "$INPUT_FILE")
            # Using 20 as the total number of chunks
            LINES_PER_CHUNK=$(( (TOTAL_LINES + 20 - 1) / 20 ))
            START_LINE=$((((${{ matrix.chunk }} - 1) * LINES_PER_CHUNK) + 1))
            END_LINE=$((${{ matrix.chunk }} * LINES_PER_CHUNK))
            sed -n "${START_LINE},${END_LINE}p" "$INPUT_FILE" > "$CHUNK_FILE"
            echo "is_empty=false" >> $GITHUB_OUTPUT
          fi

      - name: Run httpx on chunk
        if: steps.generate_chunk.outputs.is_empty == 'false'
        run: |
          httpx -l httpx-chunk-${{ matrix.chunk }}.txt -silent -threads 25 -timeout 10 -retries 2 -follow-redirects > live-urls-chunk-${{ matrix.chunk }}.txt

      - name: Create empty result file if chunk was empty
        if: steps.generate_chunk.outputs.is_empty == 'true'
        run: touch live-urls-chunk-${{ matrix.chunk }}.txt

      - name: Upload chunk result artifact
        uses: actions/upload-artifact@v4
        with:
          name: live-urls-chunk-${{ matrix.chunk }}-${{ github.event.inputs.run_id }}
          path: live-urls-chunk-${{ matrix.chunk }}.txt

  consolidate-results:
    runs-on: ubuntu-latest
    needs: scan-in-parallel
    outputs:
      artifact_name: ${{ steps.set_artifact_name.outputs.name }}
    steps:
      - name: Set final artifact name
        id: set_artifact_name
        run: echo "name=live-urls-${{ github.event.inputs.run_id }}" >> $GITHUB_OUTPUT

      - name: Download all chunk artifacts
        uses: actions/download-artifact@v4
        with:
          # No name downloads all artifacts from the run
          path: all-chunk-results

      - name: Consolidate results
        run: |
          mkdir -p final-results
          find all-chunk-results -type f -name "live-urls-chunk-*.txt" -exec cat {} + > final-results/live-urls.txt

      - name: Upload final consolidated artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.set_artifact_name.outputs.name }}
          path: final-results/live-urls.txt
